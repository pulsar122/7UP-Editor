/*****************************************************************
	7UP
	Modul: TABULAT.C
	(c) by TheoSoft '90

	Tabs expandieren und komprimieren
	
	1997-04-07 (MJK): ben”tigte Headerfiles werden geladen,
	                  compilierbar mit max. Warnungen
*****************************************************************/
#include <stdio.h>
#include <stdlib.h>
#ifdef TCC_GEM
#	include <aes.h>
#else
#	include <gem.h>
#endif
#include "windows.h"
#include "forms.h"
#include "alert.h"
#include "falert.h"
#ifndef ENGLISH											/* (GS) */
	#include "7UP.h"
#else
	#include "7UP_eng.h"
#endif

#include "tabulat.h"

#define  BLANK  ' '
#define  NEWLINE '\n'
#define  TAB	 '\t'
#define  NUL	 '\0'

char *stpexpan(register char *ptarget, char *psource, register int incr, register int tarsize, register int *linelen)
{
	 char c;
	 register int len;		/* Running total of characters put  */
									/* into ptarget, also index of next */
									/* char in ptarget.					  */
	 int numspaces;

	 len = 0;
	 tarsize--;
	 while (((c = *psource) != NUL) && (len < tarsize))	/* 1997-04-07 (MJK): NUL statt NULL */
	 {
	switch (c)
	{
		 case TAB:
		if ((incr > 0) &&
			 ((numspaces = (incr - (len % incr))) != 0))
		{
			 if ((len += numspaces) < tarsize)
			 {	 /* There's enough room.				 */
			while (numspaces--)
				 *ptarget++ = BLANK;
			break;
			 }
			 else	 /* There isn't enough room, */
			continue;	/* so quit.		  */
		}

		 /* Else TAB expansion is not in effect:			*/
		 /* just fall through and copy the TAB to ptarget.	  */

		 default:
		*ptarget++ = c;
		len++;
		break;
	}
	psource++;
	 }
	 *ptarget = '\0';
	 *linelen=len;
	 return (c ? psource : NULL);
}

char *stptabfy(char *psource, int incr)
{
	 char c;
	 register int col = 0;  /* Column counter (modulo incr).		*/
	 register int numblanks = 0; /* Number of blanks we've saved up.	*/

	 char	*pfrom = psource;
	 register char *pto	= psource;

	 do
	 {
	switch (c = *pfrom++)
	{
		 case BLANK:
		numblanks++;
		col++;
		if ((incr <= 0) ||
			 (col % incr == 0))
		{
			 *pto++	 = (char) ((numblanks > 1) ? TAB : BLANK);
			 numblanks = 0;
		}
		break;

		 case TAB:
		col	  =
		numblanks = 0;	 /* Discard the saved blanks	*/
		*pto++	  = TAB;
		break;

		 default:
		col++;
		for (; numblanks; numblanks--)
			 *pto++ = BLANK;		/* Spill any saved blanks */
		*pto++ = c;
		break;
	}
	 } while (c);

	 return (psource);
}

int hndl_tab(OBJECT *tree,WINDOW *wp)
{
	char str[3];
	int tab=0;
	if(wp)
	{
		sprintf(str,"%d",wp->tab);
		form_write(tree,TABULAT,str,0);
		if(form_exhndl(tree,TABULAT,0)==TABOK)
		{
			form_read(tree,TABULAT,str);
			if(*str)
				tab=atoi(str);
			else
				my_form_alert(1,Atabulat[0]);
			if(tab<1)
				tab=1;
		}
		else
			tab=wp->tab;
	}
	return(tab);
}
